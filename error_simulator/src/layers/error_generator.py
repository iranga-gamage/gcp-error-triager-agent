"""
Error Generator Layer - Simulates errors and creates GCP incidents.
"""

import json
import os
import time
import traceback
from datetime import datetime
from enum import Enum
from typing import Any

from google.cloud import monitoring_v3


class ErrorType(str, Enum):
    """Supported error types for simulation."""
    FILE_NOT_FOUND = "FILE_NOT_FOUND"
    INVALID_DATA = "INVALID_DATA"
    CALCULATION_ERROR = "CALCULATION_ERROR"
    MEMORY_ERROR = "MEMORY_ERROR"
    TIMEOUT = "TIMEOUT"
    EXTERNAL_SERVICE = "EXTERNAL_SERVICE"
    VALIDATION_ERROR = "VALIDATION_ERROR"


class IncidentCreator:
    """Creates GCP Cloud Monitoring incidents."""

    def __init__(self, project_id: str | None = None):
        """
        Initialize incident creator.

        Args:
            project_id: GCP project ID. Defaults to environment variable.
        """
        self.project_id = project_id or os.environ.get('GCP_PROJECT_ID')
        self.client = None

        if self.project_id:
            try:
                self.client = monitoring_v3.IncidentServiceClient()
            except Exception as e:
                print(f"Warning: Failed to initialize GCP Monitoring client: {e}")

    def create_incident(
        self,
        error_type: str,
        error_message: str,
        stack_trace: str | None = None,
        severity: str = "MEDIUM"
    ) -> dict[str, Any]:
        """
        Create a GCP incident for the error.

        Args:
            error_type: Type of error
            error_message: Error message
            stack_trace: Stack trace (optional)
            severity: Incident severity (LOW, MEDIUM, HIGH, CRITICAL)

        Returns:
            Dictionary with incident details
        """
        if not self.client or not self.project_id:
            return self._create_mock_incident(error_type, error_message, severity)

        try:
            # Create incident summary
            summary = f"[Error Simulator] {error_type}: {error_message}"

            # Build incident documentation
            documentation = self._build_incident_documentation(
                error_type, error_message, stack_trace
            )

            # Note: Creating incidents via API requires specific setup
            # For now, we'll log structured incident data that can be
            # ingested by Cloud Monitoring
            incident_data = {
                'incident_id': f"sim-{int(time.time())}-{error_type.lower()}",
                'summary': summary,
                'severity': severity,
                'state': 'OPEN',
                'start_time': datetime.utcnow().isoformat() + 'Z',
                'error_type': error_type,
                'error_message': error_message,
                'stack_trace': stack_trace,
                'documentation': documentation,
                'resource': {
                    'type': 'cloud_run_revision',
                    'project_id': self.project_id,
                    'service_name': 'error-simulator'
                }
            }

            # Log structured incident (Cloud Logging will capture this)
            print(f"INCIDENT_CREATED: {json.dumps(incident_data)}")

            return incident_data

        except Exception as e:
            print(f"Error creating incident: {e}")
            return self._create_mock_incident(error_type, error_message, severity)

    def _create_mock_incident(
        self,
        error_type: str,
        error_message: str,
        severity: str
    ) -> dict[str, Any]:
        """Create a mock incident when GCP client is unavailable."""
        return {
            'incident_id': f"mock-{int(time.time())}-{error_type.lower()}",
            'summary': f"[Mock] {error_type}: {error_message}",
            'severity': severity,
            'state': 'OPEN',
            'start_time': datetime.utcnow().isoformat() + 'Z',
            'error_type': error_type,
            'error_message': error_message,
            'note': 'This is a mock incident (GCP client not configured)'
        }

    def _build_incident_documentation(
        self,
        error_type: str,
        error_message: str,
        stack_trace: str | None
    ) -> str:
        """Build incident documentation."""
        doc = f"""
## Error Details

**Type**: {error_type}
**Message**: {error_message}
**Timestamp**: {datetime.utcnow().isoformat()}Z

## Description

This incident was generated by the Error Simulator application for testing purposes.

### Error Type: {error_type}

{self._get_error_type_description(error_type)}

## Stack Trace

```
{stack_trace or 'No stack trace available'}
```

## Recommended Actions

{self._get_recommended_actions(error_type)}
"""
        return doc.strip()

    def _get_error_type_description(self, error_type: str) -> str:
        """Get description for error type."""
        descriptions = {
            'FILE_NOT_FOUND': 'A required data file could not be found. This may indicate a deployment issue or missing configuration.',
            'INVALID_DATA': 'Data validation failed. The CSV file may be corrupted or contain invalid values.',
            'CALCULATION_ERROR': 'A calculation error occurred, such as division by zero or numeric overflow.',
            'MEMORY_ERROR': 'The application ran out of memory while processing data.',
            'TIMEOUT': 'An operation exceeded the maximum allowed time.',
            'EXTERNAL_SERVICE': 'A call to an external service failed.',
            'VALIDATION_ERROR': 'Business rule validation failed on the input data.'
        }
        return descriptions.get(error_type, 'Unknown error type')

    def _get_recommended_actions(self, error_type: str) -> str:
        """Get recommended actions for error type."""
        actions = {
            'FILE_NOT_FOUND': '1. Verify the data file exists in the expected location\n2. Check file permissions\n3. Review deployment configuration',
            'INVALID_DATA': '1. Validate the CSV file format\n2. Check for data corruption\n3. Review recent data updates',
            'CALCULATION_ERROR': '1. Review calculation logic\n2. Check for edge cases (zero values, null data)\n3. Add input validation',
            'MEMORY_ERROR': '1. Review dataset size\n2. Optimize memory usage\n3. Consider increasing Cloud Run memory limits',
            'TIMEOUT': '1. Review operation performance\n2. Check for slow queries or operations\n3. Consider increasing timeout limits',
            'EXTERNAL_SERVICE': '1. Check external service status\n2. Review network connectivity\n3. Verify API credentials',
            'VALIDATION_ERROR': '1. Review business rules\n2. Check input data quality\n3. Update validation logic if needed'
        }
        return actions.get(error_type, '1. Review error logs\n2. Contact support if issue persists')


class ErrorSimulator:
    """Simulates various error scenarios."""

    def __init__(self, project_id: str | None = None):
        """
        Initialize error simulator.

        Args:
            project_id: GCP project ID
        """
        self.incident_creator = IncidentCreator(project_id)

    def simulate_error(
        self,
        error_type: ErrorType,
        create_incident: bool = False
    ) -> dict[str, Any]:
        """
        Simulate a specific error type.

        Args:
            error_type: Type of error to simulate
            create_incident: Whether to create a GCP incident

        Returns:
            Dictionary with error details

        Raises:
            Various exceptions based on error_type
        """
        error_message = f"Simulated {error_type.value} error"
        stack_trace = None

        try:
            if error_type == ErrorType.MEMORY_ERROR:
                # Simulate memory allocation error
                raise MemoryError("Out of memory while processing large dataset")

            elif error_type == ErrorType.TIMEOUT:
                # Simulate timeout
                time.sleep(0.1)  # Brief delay to simulate work
                raise TimeoutError("Operation exceeded maximum allowed time")

            elif error_type == ErrorType.EXTERNAL_SERVICE:
                # Simulate external service failure
                raise ConnectionError("Failed to connect to external service: Connection refused")

        except Exception as e:
            error_message = str(e)
            stack_trace = traceback.format_exc()

            # Create incident if requested
            incident_data = None
            if create_incident:
                severity = self._determine_severity(error_type)
                incident_data = self.incident_creator.create_incident(
                    error_type.value,
                    error_message,
                    stack_trace,
                    severity
                )

            # Re-raise the exception with incident info
            error_info = {
                'error_type': error_type.value,
                'error_message': error_message,
                'stack_trace': stack_trace,
                'incident': incident_data
            }

            # Attach error info to exception
            e.error_info = error_info  # type: ignore
            raise

    def _determine_severity(self, error_type: ErrorType) -> str:
        """Determine incident severity based on error type."""
        severity_map = {
            ErrorType.FILE_NOT_FOUND: "HIGH",
            ErrorType.INVALID_DATA: "MEDIUM",
            ErrorType.CALCULATION_ERROR: "MEDIUM",
            ErrorType.MEMORY_ERROR: "HIGH",
            ErrorType.TIMEOUT: "MEDIUM",
            ErrorType.EXTERNAL_SERVICE: "HIGH",
            ErrorType.VALIDATION_ERROR: "LOW"
        }
        return severity_map.get(error_type, "MEDIUM")
